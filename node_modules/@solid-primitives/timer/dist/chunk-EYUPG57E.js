// src/index.ts
import { createSignal, onCleanup, createEffect, untrack, createComputed } from "solid-js";
var makeTimer = (fn, delay, timer) => {
  const intervalId = timer(fn, delay);
  const clear = () => clearInterval(intervalId);
  return onCleanup(clear);
};
var createTimer = (fn, delay, timer) => {
  if (typeof delay === "number") {
    makeTimer(fn, delay, timer);
    return;
  }
  let done = false;
  let prevTime = performance.now();
  let fractionDone = 0;
  let shouldHandleFraction = false;
  const callHandler = () => {
    untrack(fn);
    prevTime = performance.now();
    done = timer === setTimeout;
  };
  createEffect((prevDelay) => {
    if (done)
      return;
    const currDelay = delay();
    if (currDelay === false) {
      if (prevDelay)
        fractionDone += (performance.now() - prevTime) / prevDelay;
      return currDelay;
    }
    if (prevDelay === false)
      prevTime = performance.now();
    if (shouldHandleFraction) {
      if (prevDelay)
        fractionDone += (performance.now() - prevTime) / prevDelay;
      prevTime = performance.now();
      if (fractionDone >= 1) {
        fractionDone = 0;
        callHandler();
      } else if (fractionDone > 0) {
        const [listen, rerunEffect] = createSignal(void 0, { equals: false });
        listen();
        makeTimer(
          () => {
            fractionDone = 0;
            shouldHandleFraction = false;
            rerunEffect();
            callHandler();
          },
          (1 - fractionDone) * currDelay,
          setTimeout
        );
        return currDelay;
      }
    }
    shouldHandleFraction = true;
    makeTimer(callHandler, currDelay, timer);
    return currDelay;
  });
};
var createTimeoutLoop = (handler, timeout) => {
  if (typeof timeout === "number") {
    makeTimer(handler, timeout, setInterval);
    return;
  }
  const [currentTimeout, setCurrentTimeout] = createSignal(untrack(timeout));
  createEffect(() => {
    const currTimeout = currentTimeout();
    if (currTimeout === false)
      return;
    makeTimer(
      () => {
        handler();
        setCurrentTimeout(timeout);
      },
      currTimeout,
      setInterval
    );
  });
};
function createPolled(fn, timeout, value, options) {
  const [polled, setPolled] = createSignal(untrack(fn.bind(void 0, value)), options);
  const update = () => setPolled(fn);
  createTimer(update, timeout, setInterval);
  createComputed(update);
  return polled;
}
var createIntervalCounter = (timeout, options) => {
  return createPolled((prev) => prev + 1, timeout, -1, options);
};

export {
  makeTimer,
  createTimer,
  createTimeoutLoop,
  createPolled,
  createIntervalCounter
};
