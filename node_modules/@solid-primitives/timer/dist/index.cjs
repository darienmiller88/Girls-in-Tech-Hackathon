"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createIntervalCounter: () => createIntervalCounter,
  createPolled: () => createPolled,
  createTimeoutLoop: () => createTimeoutLoop,
  createTimer: () => createTimer,
  makeTimer: () => makeTimer
});
module.exports = __toCommonJS(src_exports);
var import_solid_js = require("solid-js");
var makeTimer = (fn, delay, timer) => {
  const intervalId = timer(fn, delay);
  const clear = () => clearInterval(intervalId);
  return (0, import_solid_js.onCleanup)(clear);
};
var createTimer = (fn, delay, timer) => {
  if (typeof delay === "number") {
    makeTimer(fn, delay, timer);
    return;
  }
  let done = false;
  let prevTime = performance.now();
  let fractionDone = 0;
  let shouldHandleFraction = false;
  const callHandler = () => {
    (0, import_solid_js.untrack)(fn);
    prevTime = performance.now();
    done = timer === setTimeout;
  };
  (0, import_solid_js.createEffect)((prevDelay) => {
    if (done)
      return;
    const currDelay = delay();
    if (currDelay === false) {
      if (prevDelay)
        fractionDone += (performance.now() - prevTime) / prevDelay;
      return currDelay;
    }
    if (prevDelay === false)
      prevTime = performance.now();
    if (shouldHandleFraction) {
      if (prevDelay)
        fractionDone += (performance.now() - prevTime) / prevDelay;
      prevTime = performance.now();
      if (fractionDone >= 1) {
        fractionDone = 0;
        callHandler();
      } else if (fractionDone > 0) {
        const [listen, rerunEffect] = (0, import_solid_js.createSignal)(void 0, { equals: false });
        listen();
        makeTimer(
          () => {
            fractionDone = 0;
            shouldHandleFraction = false;
            rerunEffect();
            callHandler();
          },
          (1 - fractionDone) * currDelay,
          setTimeout
        );
        return currDelay;
      }
    }
    shouldHandleFraction = true;
    makeTimer(callHandler, currDelay, timer);
    return currDelay;
  });
};
var createTimeoutLoop = (handler, timeout) => {
  if (typeof timeout === "number") {
    makeTimer(handler, timeout, setInterval);
    return;
  }
  const [currentTimeout, setCurrentTimeout] = (0, import_solid_js.createSignal)((0, import_solid_js.untrack)(timeout));
  (0, import_solid_js.createEffect)(() => {
    const currTimeout = currentTimeout();
    if (currTimeout === false)
      return;
    makeTimer(
      () => {
        handler();
        setCurrentTimeout(timeout);
      },
      currTimeout,
      setInterval
    );
  });
};
function createPolled(fn, timeout, value, options) {
  const [polled, setPolled] = (0, import_solid_js.createSignal)((0, import_solid_js.untrack)(fn.bind(void 0, value)), options);
  const update = () => setPolled(fn);
  createTimer(update, timeout, setInterval);
  (0, import_solid_js.createComputed)(update);
  return polled;
}
var createIntervalCounter = (timeout, options) => {
  return createPolled((prev) => prev + 1, timeout, -1, options);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createIntervalCounter,
  createPolled,
  createTimeoutLoop,
  createTimer,
  makeTimer
});
